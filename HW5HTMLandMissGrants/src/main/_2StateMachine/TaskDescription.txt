Предлагается запрограммировать DSL для задания конечного автомата.

Пример взят из первой главы книжки Domain Specific Languages, by Martin Fowler (http://martinfowler.com/dsl.html).
Более подробно почитать про него можно тут:
http://www.informit.com/articles/article.aspx?p=1592379 (это как раз первая глава в открытом доступе).
Нас интересует прекрасная история про Miss Grant’s Controller.

Описание предметной области:
- есть конечный автомат, картинка с конкретным примером приложена к заданию на сайте (полное описание по ссылке);
- состояния в нем можно описывать разными способами, на Java, в xml, придумывать свои DSL'и и т.д.

model/StateMachine.kt - классы для описания конечного автомата

examples/stateMachine.xml - описание в xml (приведено для примера; кода, который читает xml, нет)
examples/SetUpStateMachineJava.kt - описание, аналогичное Java коду
(код на Java сконвертирован в код на Kotlin, никакие хитрые фичи не используются)

task1/SetUpStateMachineKotlin1.kt - описание на Kotlin, небольшие улучшения по сравнению с версией на Java
task2/SetUpStateMachineKotlin2.kt - описание на Kotlin, версия, аналогичная xml (можно сравнить)

Задача: раскомментировать код, и написать все реализации функций.
Присылать, соответственно, только файлы SurnameNameTask1.kt и SurnameNameTask2.kt, которые содержат декларации функций,
благодаря которым описания конечного автомата на Kotlin компилируются и создают ту же структуру, что и Java-версия (SetUpStateMachineJava.kt).

Проверить, что все работает правильно, можно, запустив тесты в Tests.kt.
Обратите внимание, что во втором задании нужно один раз создавать State для каждого кода.
State - не data класс, и хранит все комманды и переходы внутри себя.

Если вы придумаете еще какой-нибудь третий способ для описания этого конечного автомата на Котлине,
можете реализовать и прислать мне тоже. :)